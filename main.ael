decl R;
decl T;
decl S;
decl NR;
decl G;
decl E;

decl SegmentLayer = 6;
decl CrossBridgelayer = 5;

decl macroContext;
decl library = "Anatinae_lib";

defun HC_setDrawingLayer(layer){



	if(layer == 1){
		db_set_entry_layerid( de_get_current_design_context(), db_find_layerid_by_name( de_get_current_design_context(), "m1:drawing"));
	}
	else if (layer == 2){
		db_set_entry_layerid( de_get_current_design_context(), db_find_layerid_by_name( de_get_current_design_context(), "m2:drawing"));
	}
	else if (layer == 3){
		db_set_entry_layerid( de_get_current_design_context(), db_find_layerid_by_name( de_get_current_design_context(), "m3:drawing"));
	}
	else if (layer == 4){
		db_set_entry_layerid( de_get_current_design_context(), db_find_layerid_by_name( de_get_current_design_context(), "m4:drawing"));
	}
	else if (layer == 5){
		db_set_entry_layerid( de_get_current_design_context(), db_find_layerid_by_name( de_get_current_design_context(), "m5:drawing"));
	}
	else if (layer == 6){
		db_set_entry_layerid( de_get_current_design_context(), db_find_layerid_by_name( de_get_current_design_context(), "m6:drawing"));
	}
}

defun HC_removeAll()
{
	macroContext = de_get_design_context_from_name("Anatinae_lib:main:layout");
	de_bring_context_to_top_or_open_new_window(macroContext);
	de_select_all();
	db_delete_selected(de_get_current_design_context()); 
}

defun HC_pointRotate(point,center, angle){


	decl x = point[0];
	decl y = point[1];
	decl xc = center[0];
	decl yc = center[1];

	fprintf (stderr, "LOL will rotate points (%f,%f) around (%f,%f) at angle %f\r\n",x,y,xc,yc,angle );

	decl theta = atan(( float(y)- float(yc))  /(  float(x) - float(xc)  ));
	

	if(x<xc && y>yc) theta = PI/2 - theta;
	else if(x<xc && y<yc) theta = PI + theta;
	

	decl thetaDeg =  float(theta) *(180/PI);
	decl H = sqrt( pow((y-yc),2) + pow((x-xc),2));


	decl angleRad = angle * PI/180;
	fprintf (stderr, "angle to rotate is %f and in radian is %f\r\n",angle, angleRad);
	decl xn = xc + H*cos(theta + angleRad);
	decl yn = yc + H*sin(theta + angleRad);

	fprintf (stderr, "new points are %f,%f\r\n",float(xn),float(yn));

	fprintf (stderr, "The value of theta is %f and Hypotenuse is %f and int degrees %f\r\n", theta, H, thetaDeg);
	fputs (stderr, "\n");

	return {xn,yn};
}




defun HC_getCornerCoordinates(N,C, InOut){
	decl Rh = R / cos(PI/8);
	decl Th = T*Rh/R;
	decl Sh = S*Rh/R;
	
	decl x;
	decl y;
	
	if(InOut == 0){
		x = (Rh + (N-1)*Th + (N-1)*Sh) * cos(PI/8 + (C-1)*(PI/4) ) ;
		y = (Rh + (N-1)*Th + (N-1)*Sh  ) * cos(PI/8 + (C-1)*(PI/4) ) * tan(PI/8 + (C-1)*(PI/4) ) ;
	}
	else{
		x = (Rh + (N)*Th + (N-1)*Sh) * cos(PI/8 + (C-1)*(PI/4) ) ;
		y = (Rh + (N)*Th + (N-1)*Sh) * cos(PI/8 + (C-1)*(PI/4) ) * tan(PI/8 + (C-1)*(PI/4) );
	}
	
	return {x,y};
}

defun HC_getSegmentAngle(segment){

	if(segment == 1) return 45;
	else if(segment == 2) return 90;
	else if(segment == 3) return 135;
	else if(segment == 4) return 180;
	else if(segment == 5) return 225 ;
	else if(segment == 6) return 270 ;
	else if(segment == 7) return 315 ;
	else if(segment == 8) return 360 ;
	else return 0;
}

defun HC_getSegmentLength(Ring,Segment){

	decl poly = HC_getSegmentPoly(Ring,Segment);


	decl mid_xl = (poly[0][0] + poly[1][0])/2.0;
	decl mid_yl = (poly[0][1] + poly[1][1])/2.0;
	
	decl mid_xh = (poly[2][0] + poly[3][0])/2.0;
	decl mid_yh = (poly[2][1] + poly[3][1])/2.0;
	
	
	return sqrt((mid_yh - mid_yl)^2 + (mid_xh - mid_xl)^2);
	
}

defun HC_getSegmentPoint(Ring,Segment, fraction){

	decl poly = HC_getSegmentPoly(Ring,Segment);


	decl mid_xl = (poly[0][0] + poly[1][0])/2.0;
	decl mid_yl = (poly[0][1] + poly[1][1])/2.0;
	
	decl mid_xh = (poly[2][0] + poly[3][0])/2.0;
	decl mid_yh = (poly[2][1] + poly[3][1])/2.0;
	
	
	//decl x = (mid_xl  + (percent/100)* (mid_xh - mid_xl ));
	//decl y = (mid_yl  + (percent/100)* (mid_yh - mid_yl ));
	
	decl x = mid_xl + fraction*(mid_xh - mid_xl );
	decl y = mid_yl + fraction*(mid_yh - mid_yl );
	
	
	
	//fprintf (stderr, ">>>segment (%f %f) (%f %f) (%f %f) (%f %f)\n",segment[0][0], segment[1][0],segment[0][1],segment[1][1],segment[0][2],segment[1][2],segment[0][3],segment[1][3]);
	//fprintf (stderr, "%f %f %f %f %f %f\n",mid_xl,mid_yl,mid_xh,mid_yh, x,y);
	
	return {x,y};
	
}



defun HC_getSegmentPoly(ring, seg){

	
	decl poly = {{0,0},{0,0},{0,0},{0,0}};

	if (seg == 8){
		poly[0] =	HC_getCornerCoordinates(ring,seg,0);
		poly[1] =	HC_getCornerCoordinates(ring,seg,1);
		poly[2] =	HC_getCornerCoordinates(ring,1,1);
		poly[3] =	HC_getCornerCoordinates(ring,1,0);
	}
	else{
		poly[0] =	HC_getCornerCoordinates(ring,seg,0);
		poly[1] =	HC_getCornerCoordinates(ring,seg,1);
		poly[2] =	HC_getCornerCoordinates(ring,seg+1,1);
		poly[3] =	HC_getCornerCoordinates(ring,seg+1,0);
	}
	
	return poly;
	
}




defun HC_printPolyCoordinates(poly){

	decl i;
	
	decl n = (array_size(poly));
	n = n[0];
	
	fprintf(stderr, "the number of points are : ");
	fputs(stderr, n);

	for(i=0;i<n;i++){
		decl temp_poly = poly[i];
		fprintf(stderr, "(%f,%f)", temp_poly[0],temp_poly[1]);
	}
	
	fputs(stderr, "\n");
	
}

defun HC_drawPoly(poly){
	decl i;
	
	decl n = (array_size(poly));
	n = n[0];
	
	de_add_polygon();
	for(i=0;i<n;i++){
		de_add_point(poly[i][0] , poly[i][1] );
	}
	decl shape = de_end();
	
	
}





defun HC_drawSegmentFull(Ring,Segment, Layer){

	HC_setDrawingLayer(Layer);
	HC_drawPoly(HC_getSegmentPoly(Ring,Segment));
}


defun HC_drawSegmentGapped(Ring,Segment, Layer){

	HC_setDrawingLayer(Layer);

	decl poly = HC_getSegmentPoly(Ring,Segment);
	decl Truncate_x = G/2.0;

	if(poly [0][1] > poly [1][1] ) 
		Truncate_x = Truncate_x * -1;

	de_add_polygon();
	de_add_point(poly[0][0] , poly[0][1] );
	de_add_point(poly[1][0] , poly[1][1] );
	de_add_point(Truncate_x , poly[1][1] );
	de_add_point(Truncate_x , poly[0][1] );
	de_add_point(poly[0][0] , poly[0][1] );
	decl shape = de_end();

	de_add_polygon();
	de_add_point(poly[3][0] , poly[3][1] );
	de_add_point(poly[2][0] , poly[2][1] );
	de_add_point(-Truncate_x , poly[2][1]  );
	de_add_point(-Truncate_x , poly[3][1]  );
	de_add_point(poly[3][0] , poly[3][1]  );
	decl shape = de_end();

}

defun HC_drawPlankBridge(Ring, Segment, Layer){
	HC_setDrawingLayer(Layer);
	
	decl x1 = G/2;
	decl x2 = -G/2;
	
	
	decl poly = HC_getSegmentPoly(Ring,Segment);
	
	
	decl y_in = poly[0][1];
	decl y_out = segPoly1[1][1];


	de_add_polygon();
	de_add_point(x1, y_in );
	de_add_point(x1, y_out );
	de_add_point(x2 , y_out );
	de_add_point(x2 , y_in );
	de_add_point(x1, y_in );
	decl shape = de_end();
}

defun HC_drawCrossBridge(RingInner, RingOuter, Segment, Layer){

	HC_setDrawingLayer(Layer);

	decl poly1;
	decl poly2;

	if(Segment == 2){
		poly1 = HC_getSegmentPoly(RingInner,Segment);
		poly2 = HC_getSegmentPoly(RingOuter,Segment);
	}
	else if(Segment == 6){
		poly2 = HC_getSegmentPoly(RingInner,Segment);
		poly1 = HC_getSegmentPoly(RingOuter,Segment);
	}
	
	decl x1 = G/2.0;
	decl x2 = -G/2.0;
	
	decl y1_in = poly1[0][1];
	decl y1_out = poly1[1][1];
	decl y2_in = poly2[3][1];
	decl y2_out = poly2[2][1];

	de_add_polygon();
	de_add_point(x1, y1_in );
	de_add_point(x1, y1_out );
	de_add_point(x2 , y2_out );
	de_add_point(x2 , y2_in );
	de_add_point(x1, y1_in );
	decl shape = de_end();
	
	
}


defun HC_drawCrossBridgeExtension(RingInner, RingOuter, Segment, Layer){
	HC_setDrawingLayer(Layer);
	
	decl poly1;
	decl poly2;

	decl x1 = G/2.0;
	decl x2 = -G/2.0;


	decl y1_in;
	decl y1_out;
	decl y2_in;
	decl y2_out;




	if(Segment == 2){
		poly1 = HC_getSegmentPoly(RingInner,Segment);
		poly2 = HC_getSegmentPoly(RingOuter,Segment);
		
		y1_in = poly1[0][1];
		y1_out = poly1[1][1];
		y2_in = poly2[3][1];
		y2_out = poly2[2][1];
		
	}
	else if(Segment == 6){
		poly2 = HC_getSegmentPoly(RingInner,Segment);
		poly1 = HC_getSegmentPoly(RingOuter,Segment);
		
		y1_out = poly1[0][1];
		y1_in = poly1[1][1];
		y2_out = poly2[3][1];
		y2_in = poly2[2][1];
	}
	


		
	de_add_polygon();
	de_add_point(x1, y1_in );
	de_add_point(x1, y1_out );
	de_add_point(x1+E, y1_out );
	de_add_point(x1+E, y1_in );
	de_add_point(x1, y1_in );
	decl shape = de_end();
	
	
	HC_drawVias(x1,x1+E,y1_in,y1_out, Layer,SegmentLayer);
	
	
	de_add_polygon();
	de_add_point(x2, y2_in );
	de_add_point(x2, y2_out );
	de_add_point(x2-E, y2_out );
	de_add_point(x2-E, y2_in );
	de_add_point(x1, y2_in );
	decl shape = de_end();
	
	HC_drawVias(x2-E,x2,y2_in,y2_out, Layer,SegmentLayer);
	

}

defun HC_drawVias(x1,x2,y1,y2, layer1, layer2){


	decl dx = float(0.36);
	decl dy = float(0.36);
	decl ds = float(0.34);


	decl padstack; 
	//decl layer1; 
	//decl layer2;


	switch(layer1){
		case 9: {
			dx = float(3);
			dy = float(3);
			ds = float(3);
			padstack = "via0.36um"; 
			break;
		}
		case 8: {
			dx = float(.36);
			dy = float(.34);
			ds = float(.34);			
			padstack = "via0.36um"; 
			break;
		}
		case 7: {
			dx = float(.36);
			dy = float(.34);
			ds = float(.34);
			padstack = "via0.36um"; 
			break;
		}
		case 6: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um"; 
			break;
		}
		case 5: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um"; 		
			break;
		}
		case 4: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um"; 	
			break;
		}
		case 3: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um"; 		
			break;
		}
		case 2: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um"; 	
			break;
		}
		case 1: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);	
			padstack = "via0.1um"; 
			break;
		}		
	}



	fprintf (stderr, ">>> x1 = %f, x2 = %f, y1 = %f, y2 = %f\n", x1,x2,y1,y2);

	decl X = (x2 - x1);
	if (X < 0) X = X*-1;
	//fprintf (stderr, "The value of side %s is %f\n", "X", X);

	decl Y = (y2 - y1);
	if (Y < 0) Y = Y*-1;
	//fprintf (stderr, "The value of side %s is %f\n", "Y", Y);

	decl nx = floor((X + ds)/(dx + ds));
	//fprintf (stderr, "The value of %s is %f\n", "nx", nx);

	decl ny = floor((Y + ds)/(dy + ds));
	//fprintf (stderr, "The value of %s is %f\n", "ny", ny);


	decl side_x = (X - (nx*dx + (nx-1)*ds))/2;
	//fprintf (stderr, "The value of side %s is %f\n", "x", side_x);

	decl side_y = (Y - (ny*dy + (ny-1)*ds))/2;
	//fprintf (stderr, "The value of side %s is %f\n", "y", side_y);


	decl ix;
	decl iy;

	




	for(ix = 0;ix<nx;ix++){
			for(iy = 0;iy<ny;iy++){
				decl pos_x = x1 + side_x + dx/2 + (dx + ds)*ix;
				decl pos_y = y1 + side_y + dy/2 + (dy + ds)*iy;
				//fprintf (stderr, ">>>%f,%f\n", pos_x,pos_y);
				//db_create_constraint_pcb_via(macroContext, "Anatinae_lib", via, pos_x, pos_y);
				HC_drawPadstackVia(padstack, layer1, layer2, pos_x, pos_y);
				de_select_range(pos_x, pos_y, pos_x, pos_y, 1, 1);
				//de_rotate(pos_x, pos_y, angle, 1, 0);
		}
	}
}

defun HC_drawCenterTapPort(center, angle, port, layer){


	decl pin = db_create_pin(macroContext, center[0], center[1], angle, db_layerid(layer), port);
}


defun HC_drawCenterTapArm(center, length, width, angle, Layer, port){
	HC_setDrawingLayer(Layer);

	decl r0 = {center[0]- width/2.0, center[1] + width/2.0};
	decl r1 = {center[0]- width/2.0, center[1] - width/2.0};
	decl r2 = {center[0]+ length, center[1] - width/2.0};
	decl r3 = {center[0]+ length, center[1] + width/2.0};

	r0 = HC_pointRotate(r0, center, angle);
	r1 = HC_pointRotate(r1, center, angle);
	r2 = HC_pointRotate(r2, center, angle);
	r3 = HC_pointRotate(r3, center, angle);

	fprintf(stderr, "ROTATED: (%f %f) (%f %f) (%f %f) (%f %f)\n\n", r0[0],r0[1],r1[0],r1[1],r2[0],r2[1],r3[0],r3[1] );
	fputs(stderr, "\n");
	de_add_polygon();
	de_add_point(r0[0], r0[1]);
	de_add_point(r1[0], r1[1]);
	de_add_point(r2[0], r2[1]);
	de_add_point(r3[0], r3[1]);
	de_add_point(r0[0], r0[1]);
	decl shape = de_end();
	
	decl mid = {0,0};
	mid[0]  = (r2[0] + r3[0])/2.0;
	mid[1]  = (r2[1] + r3[1])/2.0;
	
	
	fprintf(stderr, "PORT at %f,%f\n", mid[0],mid[1]);
	HC_drawCenterTapPort(mid, angle,port,Layer);
	
		
}

defun HC_drawPadstackVia(padstack, layer1, layer2, x,y){
	db_create_pcb_via_with_top_bottom_layers(macroContext, library, padstack, db_layerid(layer2), db_layerid(layer1), x, y, 1);
}


defun HC_drawCenterTapVias(center, length,width, angle, viaLayer1, viaLayer2){

	de_deselect_all();
	decl viaName;
	decl dx;
	decl dy;
	decl ds;

	decl padstack; 


	switch(viaLayer1){
		case 9: {
			dx = float(3);
			dy = float(3);
			ds = float(3);
			padstack = "via3um";
			break;
		}
		case 8: {
			dx = float(.36);
			dy = float(.34);
			ds = float(.34);
			padstack = "via0.36um";
			break;
		}
		case 7: {
			dx = float(.36);
			dy = float(.34);
			ds = float(.34);
			padstack = "via0.36um";
			break;
		}
		case 6: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um";
			break;
		}
		case 5: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um";
			break;
		}
		case 4: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um";
			break;
		}
		case 3: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um";
			break;
		}
		case 2: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um";
			break;
		}
		case 1: {
			dx = float(.1);
			dy = float(.1);
			ds = float(.1);
			padstack = "via0.1um";
			break;
		}		
	}



	decl mid_x = center[0];
	decl mid_y = center[1];

	decl x1 = 	mid_x - length/2;
	decl x2 = 	mid_x + length/2;
	
	decl y1 =   mid_y - width/2;
	decl y2 =   mid_y + width/2;

	
	decl X = (x2 - x1);
	if (X < 0) X = X*-1;
	//fprintf (stderr, "The value of side %s is %f\n", "X", X);

	decl Y = (y2 - y1);
	if (Y < 0) Y = Y*-1;
	//fprintf (stderr, "The value of side %s is %f\n", "Y", Y);

	decl nx = floor((X + ds)/(dx + ds));
	//fprintf (stderr, "The value of %s is %f\n", "nx", nx);

	decl ny = floor((Y + ds)/(dy + ds));
	//fprintf (stderr, "The value of %s is %f\n", "ny", ny);


	decl side_x = (X - (nx*dx + (nx-1)*ds))/2;
	//fprintf (stderr, "The value of side %s is %f\n", "x", side_x);

	decl side_y = (Y - (ny*dy + (ny-1)*ds))/2;
	//fprintf (stderr, "The value of side %s is %f\n", "y", side_y);


	decl ix;
	decl iy;

	for(ix = 0;ix<nx;ix++){
			for(iy = 0;iy<ny;iy++){
				de_deselect_all();
				decl pos_x = x1 + side_x + dx/2 + (dx + ds)*ix;
				decl pos_y = y1 + side_y + dy/2 + (dy + ds)*iy;
				//fprintf (stderr, ">>>%f,%f\n", pos_x,pos_y);
				HC_drawPadstackVia(padstack, viaLayer1, viaLayer2, pos_x, pos_y);
				de_select_range(pos_x, pos_y, pos_x, pos_y, 1, 1);
				de_rotate(mid_x, mid_y, angle, 1, 0);
		}
	}

	de_deselect_all();
}



defun HC_drawCenterTap(ring,segment,fraction,armLength,armThickness,port,layer1,layer2){


	HC_setDrawingLayer(layer1);
	decl angle = HC_getSegmentAngle(segment);
	decl center = HC_getSegmentPoint(ring,segment, fraction);
	HC_drawCenterTapVias(center, armThickness,armThickness, angle, layer1, layer2);
	HC_drawCenterTapArm(center, armLength, armThickness, angle,layer1, port);

}

defun main(Radius,Thickness,Spacing,RingCount,Gap, Ext){
	HC_removeAll();

	fputs(stderr, "START\n");
	
	
	R = Radius;
	T = Thickness;
	S = Spacing;
	NR = RingCount;
	G = Gap;
	E = Ext;
	
	fprintf (stderr, "Radius:%f\nThickness:%f\nSpacing:%f\nRing Count:%f\nGap Spacing:%f\n\r\n",R,T,S,NR,G);


	HC_setDrawingLayer(2);

	//HC_drawCenterTapPort({25,25}, 55, 3);
	
	HC_drawCenterTap(1,1,0.5,50,T,2,SegmentLayer-1,SegmentLayer);
	HC_drawCenterTap(1,3,0.5,50,T,3,SegmentLayer-1,SegmentLayer);
	HC_drawCenterTap(1,6,0.2,50,T,1,SegmentLayer-2,SegmentLayer);
	HC_drawCenterTap(1,6,0.8,50,T,4,SegmentLayer-2,SegmentLayer);

	HC_setDrawingLayer(6);
	

	//return;
	
	
	decl i;
	decl ii;
	
	for(i = 1;i<=NR;i++){
		for(ii = 1;ii <= 8 ; ii++){
			fprintf(stderr, ">>>>> ring %f , segment  %f <<<<<\n", i,ii);

			if(ii == 2 || ii == 6){
				if(i==NR){
				
					if((i%2 ==1 && ii==2) || (i%2 ==0 && ii==6)){
						
						HC_drawSegmentFull(i,ii,SegmentLayer);
					}
					else{
						fprintf(stderr, ">>>>> drawing gapped segment <<<<<\n");
						HC_drawSegmentGapped(i,ii,SegmentLayer);
					}
				}
				else{
					HC_drawSegmentGapped(i,ii,SegmentLayer);

					if((i%2 == 0  && ii == 6) || (i%2 == 1  && ii == 2) ){
						fprintf(stderr, ">>>>> drawing cross bridge <<<<<\n");
						HC_drawCrossBridge(i, i+1, ii, CrossBridgelayer);
						HC_drawCrossBridgeExtension(i, i+1, ii, CrossBridgelayer);
						HC_drawCrossBridge(i+1, i, ii, SegmentLayer);
					}
					
				}
				
				
				
			}else{
			
				HC_drawSegmentFull(i,ii,SegmentLayer);
			}	
		}
	}

	fputs(stderr, "END\n\n");
}